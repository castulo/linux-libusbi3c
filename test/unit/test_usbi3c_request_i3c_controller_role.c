/***************************************************************************
  USBI3C  -  Library to talk to I3C devices via USB.
  -------------------
  copyright            : (C) 2022 Intel Corporation
  SPDX-License-Identifier: LGPL-2.1-only
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License           *
 *   version 2.1 as published by the Free Software Foundation.             *
 *                                                                         *
 ***************************************************************************/

#include "helpers.h"
#include "mocks.h"

struct test_deps {
	struct usbi3c_device *usbi3c_dev;
};

static int test_setup(void **state)
{
	struct test_deps *deps = (struct test_deps *)malloc(sizeof(struct test_deps));

	deps->usbi3c_dev = helper_usbi3c_init(NULL);
	helper_initialize_controller(deps->usbi3c_dev, NULL, NULL);

	*state = deps;

	return 0;
}

static int test_teardown(void **state)
{
	struct test_deps *deps = (struct test_deps *)*state;

	helper_usbi3c_deinit(&deps->usbi3c_dev, NULL);
	free(deps);

	return 0;
}

/* Negative test to validate that the function handles a missing context gracefully */
static void test_negative_missing_context(void **state)
{
	(void)state; /* unused */
	int ret = 0;

	ret = usbi3c_request_i3c_controller_role(NULL);
	assert_int_equal(ret, RETURN_FAILURE);
}

/* Negative test to validate that the function handles a device with the wrong role gracefully */
static void test_negative_unknown_capability(void **state)
{
	struct test_deps *deps = (struct test_deps *)*state;
	struct device_info *tmp = NULL;
	int ret = 0;

	/* force a condition of an unkown capability */
	tmp = deps->usbi3c_dev->device_info;
	deps->usbi3c_dev->device_info = NULL;

	ret = usbi3c_request_i3c_controller_role(deps->usbi3c_dev);
	assert_int_equal(ret, RETURN_FAILURE);

	deps->usbi3c_dev->device_info = tmp;
}

/* Negative test to validate that the function handles a device with an unknown capability gracefully */
static void test_negative_wrong_role(void **state)
{
	struct test_deps *deps = (struct test_deps *)*state;
	int ret = 0;

	ret = usbi3c_request_i3c_controller_role(deps->usbi3c_dev);
	assert_int_equal(ret, RETURN_FAILURE);
}

/* Negative test to validate that the function handles attempting to request the role being already the active controller gracefully */
static void test_negative_already_active_controller(void **state)
{
	struct test_deps *deps = (struct test_deps *)*state;
	int ret = 0;

	deps->usbi3c_dev->device_info->device_role = USBI3C_TARGET_DEVICE_SECONDARY_CONTROLLER_ROLE;

	ret = usbi3c_request_i3c_controller_role(deps->usbi3c_dev);
	assert_int_equal(ret, RETURN_FAILURE);
}

/* Test to validate that a target device capable of secondary controller can send a request to become the active I3C controller */
static void test_usbi3c_request_i3c_controller_role(void **state)
{
	struct test_deps *deps = (struct test_deps *)*state;
	unsigned char *request_buffer = NULL;
	unsigned char *response_buffer = NULL;
	int request_buffer_size = 0;
	int response_buffer_size = 0;
	int buffer_available = 1000;
	int ret = 0;

	deps->usbi3c_dev->device_info->device_role = USBI3C_TARGET_DEVICE_SECONDARY_CONTROLLER_ROLE;
	deps->usbi3c_dev->device_info->device_state.active_i3c_controller = FALSE;

	/* the hot-join request is sent as a sync bulk request transfer,
	 * let's create the type of buffer we expect so we can compare it
	 * against the one generated by the library */
	request_buffer_size = helper_create_command_buffer(bulk_request_id,
							   &request_buffer,
							   USBI3C_DEVICE_STATIC_ADDRESS,
							   USBI3C_WRITE,
							   USBI3C_TERMINATE_ON_ANY_ERROR,
							   USBI3C_RESPONSE_HAS_NO_DATA,
							   NULL,
							   DEFAULT_TRANSFER_MODE,
							   DEFAULT_TRANSFER_RATE,
							   USBI3C_NOT_DEPENDENT_ON_PREVIOUS);

	/* once the target device has succeeded or failed hot-joining a bus it
	 * informs the host about it using a bulk response transfer. Let's create
	 * the type of buffer we expect to receive so we mock a response from a device */
	struct usbi3c_response response = { 0 };
	response.attempted = USBI3C_COMMAND_ATTEMPTED;
	response.error_status = USBI3C_SUCCEEDED;
	response.has_data = USBI3C_RESPONSE_HAS_NO_DATA;
	response.data_length = 0;
	response.data = NULL;
	response_buffer_size = helper_create_response_buffer(&response_buffer,
							     &response,
							     bulk_request_id);

	/* mock the USB related functions */
	mock_get_buffer_available(NULL, &buffer_available, RETURN_SUCCESS);
	mock_usb_output_bulk_transfer(request_buffer, request_buffer_size, RETURN_SUCCESS);
	mock_usb_wait_for_next_event(USBI3C_BULK_TRANSFER_ENDPOINT_INDEX, response_buffer, response_buffer_size, RETURN_SUCCESS);

	ret = usbi3c_request_i3c_controller_role(deps->usbi3c_dev);
	assert_int_equal(ret, RETURN_SUCCESS);

	free(request_buffer);
	free(response_buffer);
}

int main(void)
{
	/* Unit tests for the usbi3c_request_i3c_controller_role() function */
	const struct CMUnitTest tests[] = {
		cmocka_unit_test_setup_teardown(test_negative_missing_context, test_setup, test_teardown),
		cmocka_unit_test_setup_teardown(test_negative_unknown_capability, test_setup, test_teardown),
		cmocka_unit_test_setup_teardown(test_negative_wrong_role, test_setup, test_teardown),
		cmocka_unit_test_setup_teardown(test_negative_already_active_controller, test_setup, test_teardown),
		cmocka_unit_test_setup_teardown(test_usbi3c_request_i3c_controller_role, test_setup, test_teardown),
	};

	return cmocka_run_group_tests(tests, NULL, NULL);
}
