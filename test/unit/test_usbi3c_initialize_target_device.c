/***************************************************************************
  USBI3C  -  Library to talk to I3C devices via USB.
  -------------------
  copyright            : (C) 2022 Intel Corporation
  SPDX-License-Identifier: LGPL-2.1-only
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License           *
 *   version 2.1 as published by the Free Software Foundation.             *
 *                                                                         *
 ***************************************************************************/

#include "helpers.h"
#include "mocks.h"

struct test_deps {
	struct usbi3c_device *usbi3c_dev;
};

static int test_setup(void **state)
{
	struct test_deps *deps = (struct test_deps *)malloc(sizeof(struct test_deps));

	deps->usbi3c_dev = helper_usbi3c_init(NULL);

	*state = deps;

	return 0;
}

static int test_teardown(void **state)
{
	struct test_deps *deps = (struct test_deps *)*state;

	helper_usbi3c_deinit(&deps->usbi3c_dev, NULL);
	free(deps);

	return 0;
}

/* Negative test to validate that the function handles an unknown/unsupported role gracefully */
static void test_negative_unsupported_role(void **state)
{
	struct test_deps *deps = (struct test_deps *)*state;
	unsigned char *cap_buffer = NULL;
	int ret = 0;
	const int UNSUPPORTED_ROLE = 4;

	/* mock the usb functions that get called during a target device initialization */
	cap_buffer = mock_get_i3c_capability(NULL,
					     DEVICE_CONTAINS_CAPABILITY_DATA,
					     UNSUPPORTED_ROLE,
					     NO_STATIC_DATA,
					     DEFAULT_TARGET_CAPABILITY,
					     NO_DEVICES_IN_BUS,
					     RETURN_SUCCESS);

	mock_usb_bulk_transfer_response_buffer_init(RETURN_SUCCESS);
	mock_usb_input_bulk_transfer_polling(RETURN_SUCCESS);

	ret = usbi3c_initialize_device(deps->usbi3c_dev);
	assert_int_equal(ret, RETURN_FAILURE);

	free(cap_buffer);
}

/* Negative test to validate that the function handles a libusb failure gracefully */
static void test_negative_libusb_failure(void **state)
{
	struct test_deps *deps = (struct test_deps *)*state;
	unsigned char *cap_buffer = NULL;
	unsigned char *request_buffer = NULL;
	unsigned char *response_buffer = NULL;
	int request_buffer_size = 0;
	int buffer_available = 1000;
	int ret = 0;

	/* when initializing a target device we send a bulk request transfer to it,
	 * let's create the type of buffer we expect so we can compare it against
	 * the one generated by the library */
	request_buffer_size = helper_create_command_buffer(bulk_request_id,
							   &request_buffer,
							   HOT_JOIN_ADDRESS,
							   USBI3C_WRITE,
							   USBI3C_TERMINATE_ON_ANY_ERROR,
							   0,
							   NULL,
							   DEFAULT_TRANSFER_MODE,
							   DEFAULT_TRANSFER_RATE,
							   USBI3C_NOT_DEPENDENT_ON_PREVIOUS);

	/* mock the usb functions that get called during a target device initialization */
	cap_buffer = mock_get_i3c_capability(NULL,
					     DEVICE_CONTAINS_CAPABILITY_DATA,
					     USBI3C_TARGET_DEVICE_ROLE,
					     NO_STATIC_DATA,
					     DEFAULT_TARGET_CAPABILITY,
					     NO_DEVICES_IN_BUS,
					     RETURN_SUCCESS);

	mock_usb_bulk_transfer_response_buffer_init(RETURN_SUCCESS);
	mock_usb_input_bulk_transfer_polling(RETURN_SUCCESS);
	mock_get_buffer_available(NULL, &buffer_available, RETURN_SUCCESS);
	mock_usb_output_bulk_transfer(request_buffer, request_buffer_size, RETURN_FAILURE);

	ret = usbi3c_initialize_device(deps->usbi3c_dev);
	/* the initialization should return the hot-join error all the way to the user */
	assert_int_equal(ret, RETURN_FAILURE);

	free(cap_buffer);
	free(request_buffer);
	free(response_buffer);
}

/* Negative test to validate that the function handles a hot-join failure gracefully */
static void test_negative_hot_join_failure(void **state)
{
	struct test_deps *deps = (struct test_deps *)*state;
	unsigned char *cap_buffer = NULL;
	unsigned char *request_buffer = NULL;
	unsigned char *response_buffer = NULL;
	int request_buffer_size = 0;
	int response_buffer_size = 0;
	int buffer_available = 1000;
	int ret = 0;

	/* when initializing a target device we send a bulk request transfer to it,
	 * let's create the type of buffer we expect so we can compare it against
	 * the one generated by the library */
	request_buffer_size = helper_create_command_buffer(bulk_request_id,
							   &request_buffer,
							   HOT_JOIN_ADDRESS,
							   USBI3C_WRITE,
							   USBI3C_TERMINATE_ON_ANY_ERROR,
							   0,
							   NULL,
							   DEFAULT_TRANSFER_MODE,
							   DEFAULT_TRANSFER_RATE,
							   USBI3C_NOT_DEPENDENT_ON_PREVIOUS);

	/* once the target device has succeeded or failed hot-joining a bus it
	 * informs the host about it using a bulk response transfer. Let's create
	 * the type of buffer we expect to receive so we mock a response from a device */
	struct usbi3c_response response;
	response.attempted = USBI3C_COMMAND_ATTEMPTED;
	response.error_status = USBI3C_FAILED_I3C_CONTROLLER_ERROR;
	response.has_data = USBI3C_RESPONSE_HAS_NO_DATA;
	response.data_length = 0;
	response.data = NULL;
	response_buffer_size = helper_create_response_buffer(&response_buffer,
							     &response,
							     bulk_request_id);

	/* mock the usb functions that get called during a target device initialization */
	cap_buffer = mock_get_i3c_capability(NULL,
					     DEVICE_CONTAINS_CAPABILITY_DATA,
					     USBI3C_TARGET_DEVICE_ROLE,
					     NO_STATIC_DATA,
					     DEFAULT_TARGET_CAPABILITY,
					     NO_DEVICES_IN_BUS,
					     RETURN_SUCCESS);

	mock_usb_bulk_transfer_response_buffer_init(RETURN_SUCCESS);
	mock_usb_input_bulk_transfer_polling(RETURN_SUCCESS);
	mock_get_buffer_available(NULL, &buffer_available, RETURN_SUCCESS);
	mock_usb_output_bulk_transfer(request_buffer, request_buffer_size, RETURN_SUCCESS);
	mock_usb_wait_for_next_event(USBI3C_BULK_TRANSFER_ENDPOINT_INDEX, response_buffer, response_buffer_size, RETURN_SUCCESS);

	ret = usbi3c_initialize_device(deps->usbi3c_dev);
	/* the initialization should return the hot-join error all the way to the user */
	assert_int_equal(ret, USBI3C_FAILED_I3C_CONTROLLER_ERROR);

	free(cap_buffer);
	free(request_buffer);
	free(response_buffer);
}

/* Test to validate the I3C target device can be initialized successfully */
static void test_usbi3c_initialize_target_device(void **state)
{
	struct test_deps *deps = (struct test_deps *)*state;
	unsigned char *cap_buffer = NULL;
	unsigned char *request_buffer = NULL;
	unsigned char *response_buffer = NULL;
	int request_buffer_size = 0;
	int response_buffer_size = 0;
	int buffer_available = 1000;
	int ret = -1;

	/* when initializing a target device we send a bulk request transfer to it,
	 * let's create the type of buffer we expect so we can compare it against
	 * the one generated by the library */
	request_buffer_size = helper_create_command_buffer(bulk_request_id,
							   &request_buffer,
							   HOT_JOIN_ADDRESS,
							   USBI3C_WRITE,
							   USBI3C_TERMINATE_ON_ANY_ERROR,
							   0,
							   NULL,
							   DEFAULT_TRANSFER_MODE,
							   DEFAULT_TRANSFER_RATE,
							   USBI3C_NOT_DEPENDENT_ON_PREVIOUS);

	/* once the target device has succeeded or failed hot-joining a bus it
	 * informs the host about it using a bulk response transfer. Let's create
	 * the type of buffer we expect to receive so we mock a response from a device */
	struct usbi3c_response response;
	response.attempted = USBI3C_COMMAND_ATTEMPTED;
	response.error_status = USBI3C_SUCCEEDED;
	response.has_data = USBI3C_RESPONSE_HAS_NO_DATA;
	response.data_length = 0;
	response.data = NULL;
	response_buffer_size = helper_create_response_buffer(&response_buffer,
							     &response,
							     bulk_request_id);

	/* mock the usb functions that get called during a target device initialization */
	cap_buffer = mock_get_i3c_capability(NULL,
					     DEVICE_CONTAINS_CAPABILITY_DATA,
					     USBI3C_TARGET_DEVICE_ROLE,
					     NO_STATIC_DATA,
					     DEFAULT_TARGET_CAPABILITY,
					     NO_DEVICES_IN_BUS,
					     RETURN_SUCCESS);

	mock_usb_bulk_transfer_response_buffer_init(RETURN_SUCCESS);
	mock_usb_input_bulk_transfer_polling(RETURN_SUCCESS);
	mock_get_buffer_available(NULL, &buffer_available, RETURN_SUCCESS);
	mock_usb_output_bulk_transfer(request_buffer, request_buffer_size, RETURN_SUCCESS);
	mock_usb_wait_for_next_event(USBI3C_BULK_TRANSFER_ENDPOINT_INDEX, response_buffer, response_buffer_size, RETURN_SUCCESS);

	ret = usbi3c_initialize_device(deps->usbi3c_dev);
	assert_int_equal(ret, USBI3C_SUCCEEDED);

	/* the command that was created and sent for hot-join should have
	 * been removed */
	assert_null(deps->usbi3c_dev->command_queue);
	assert_null(deps->usbi3c_dev->request_tracker->regular_requests->requests);

	free(cap_buffer);
	free(request_buffer);
	free(response_buffer);
}

int main(void)
{

	/* Unit tests for the usbi3c_initialize_device() function */
	const struct CMUnitTest tests[] = {
		cmocka_unit_test_setup_teardown(test_negative_unsupported_role, test_setup, test_teardown),
		cmocka_unit_test_setup_teardown(test_negative_libusb_failure, test_setup, test_teardown),
		cmocka_unit_test_setup_teardown(test_negative_hot_join_failure, test_setup, test_teardown),
		cmocka_unit_test_setup_teardown(test_usbi3c_initialize_target_device, test_setup, test_teardown),
	};

	return cmocka_run_group_tests(tests, NULL, NULL);
}
